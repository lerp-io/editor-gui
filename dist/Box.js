// Generated by CoffeeScript 2.5.1
var BAR_DIM, Box, MIN_HEIGHT, MIN_WIDTH, REBAR_DIM, h;

import {
  createElement,
  useState,
  useEffect,
  useRef,
  useContext
} from 'react';

import LayoutContext from './LayoutContext';

import BoxContext from './BoxContext';

import cn from 'classnames';

import {
  clampPosition,
  getPosition,
  fixAlign,
  guessAlign,
  clampHeight,
  clampWidth
} from './Align';

h = createElement;

MIN_HEIGHT = 50;

MIN_WIDTH = 300;

BAR_DIM = 12;

REBAR_DIM = 4;

Box = function(props, state) {
  var align_key, content_ref, context, dim_overflow, height, offset_x, offset_y, self_context, self_ref, self_x, self_y, setDim, setVisible, style, visible, width, x, y;
  [visible, setVisible] = useState(false);
  [dim_overflow, setDim] = useState([MIN_HEIGHT, 0]);
  // [width_overflow,setWidth] = useState([MIN_WIDTH,0])
  self_ref = useRef(null);
  content_ref = useRef(null);
  height = dim_overflow[0];
  width = dim_overflow[2];
  style = {
    overflowY: dim_overflow[1],
    overflowX: dim_overflow[3]
  };
  context = useContext(LayoutContext);
  self_context = {
    startDrag: context.startDrag,
    stopDrag: context.stopDrag
  };
  useEffect(function() {
    var content_height, content_width, overflow_x, overflow_y, ref, ref1, set_height, set_width;
    if (content_ref.current) {
      content_width = Math.max(((ref = content_ref.current) != null ? ref.scrollWidth : void 0) || 0, MIN_WIDTH);
      content_height = Math.max(((ref1 = content_ref.current) != null ? ref1.scrollHeight : void 0) || 0, MIN_HEIGHT);
      set_height = clampHeight(context, content_height);
      set_width = clampWidth(context, content_width);
      if (set_width < content_width) {
        overflow_x = 'scroll';
      } else {
        overflow_x = void 0;
      }
      if (set_height < content_height) {
        overflow_y = 'scroll';
      } else {
        overflow_y = void 0;
      }
      if (set_width !== dim_overflow[2] || set_height !== dim_overflow[0] || overflow_y !== dim_overflow[1] || overflow_x !== dim_overflow[3]) {
        self_ref.current.style.width = set_width;
        self_ref.current.style.height = set_height;
        setDim([set_height, overflow_y, set_width, overflow_x]);
      }
      if (!visible) {
        return setVisible(true);
      }
    }
  });
  if (!context) {
    return null;
  }
  style.minHeight = MIN_HEIGHT;
  style.height = height;
  style.width = width;
  if (props.align) {
    align_key = props.align;
  } else {
    align_key = guessAlign(width, height, context);
    [x, y] = getPosition(width, height, context, align_key);
    align_key = fixAlign(align_key, context, width, height);
  }
  if (props.position) {
    self_x = props.position[0];
    self_y = props.position[1];
  } else if (context.root) {
    self_x = context.x;
    self_y = context.y;
  } else {
    [self_x, self_y] = getPosition(width, height, context, align_key);
    [offset_x, offset_y] = clampPosition(context, self_x, self_y, width, height, align_key);
    self_x += offset_x;
    self_y += offset_y;
  }
  style.zIndex = context.depth + 1 + 888;
  style.left = self_x + 'px';
  style.top = self_y + 'px';
  return h('div', {
    ref: self_ref,
    style: style,
    className: cn('ed-box', !visible && 'ed-hidden', 'noselect')
  }, h('div', {
    cn: 'ed-box-inner',
    style: {
      minHeight: MIN_HEIGHT,
      paddingTop: !props.title && '0.425em'
    },
    ref: content_ref
  }, (props.title || props.label) && (h('div', {
    className: cn('ed-box-title', props.stickyTitle && 'ed-box-title-sticky')
  }, h('div', {
    className: 'ed-in-label-colon'
  }, '# '), props.title || props.label)) || null, props.description && (h('div', {
    className: 'ed-description'
  }, props.description)) || null, h('div', {
    className: 'ed-box-content'
  }, h(BoxContext.Provider, {
    value: self_context
  }, props.children))));
};

export default Box;

//# sourceMappingURL=Box.js.map
